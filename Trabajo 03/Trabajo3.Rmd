---
title: |
  \includegraphics[width=26cm]{EscudoUN.png}  
  \thispagestyle{empty} 
  \vspace*{2.0cm} 
  \textbf{\huge Modelado de datos en áreas}  
  \vspace{1cm}
subtitle: |
 | \LARGE Estadística espacial
 | \vspace{4.07cm}
author: |
 |  \Large \textbf{Daniela Arbeláez Montoya}
 |  \Large \textbf{Jefferson Gamboa Betancur}
 |  \Large \textbf{Jean Paul Piedrahita García}
 |  \vspace{5cm}
date: |
  | \small Universidad Nacional de Colombia
  | Ciencias, Escuela de Estadística
  | Medellín, Colombia
  | 2021
documentclass: article
geometry: 
  - top=2cm
  - left=1.8cm
  - right=2cm
  - bottom=2.54cm
fontsize: 12pt
pagestyle: empty
papersize: a4
linestretch: 1.5
linkcolor: blue
links-as-notes: true
lang: "es"
header-includes:
- \usepackage[utf8]{inputenc}
- \setlength{\parindent}{0pt}
- \usepackage{graphicx}
- \pagenumbering{gobble}
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{threeparttablex}
- \usepackage[normalem]{ulem}
- \usepackage{makecell}
- \usepackage{xcolor}
- \usepackage{hyperref}
output: 
    pdf_document: 
      toc: yes
      toc_depth: 3
      number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  cache = TRUE,
  message = FALSE,
  error = FALSE,
  warning = FALSE,
  tidy.opts=list(width.cutoff = 80),
  tidy = TRUE,
  prompt = TRUE
  )
options(kableExtra.latex.load_packages = FALSE)
require(kableExtra)
```

```{=tex}
\newpage
\pagenumbering{arabic}
\setcounter{page}{2}
\pagestyle{plain}
```
```{r, echo = FALSE}
ITabla <- function(M){
  kbl(M, booktabs = T) %>%
  kable_styling(latex_options = c("striped", "hold_position"))
}
```

# Introducción

A lo largo del desarrollo de este documento, se mostrará la construcción de vecinos y los pesos que se pueden aplicar a los vecindarios. Una vez que este importante y a menudo exigente prerrequisito esté en su lugar, se procede a buscar formas de medir la autocorrelación espacial.

Si bien las pruebas se basan en modelos de procesos espaciales, primero se examinan las pruebas y solo posteriormente se pasa al modelado. También es interesante mostrar cómo se puede introducir la autocorrelación espacial en datos independientes, de modo que se puedan realizar simulaciones.

El conjunto de datos con el que se trabajará en esta ocasión, contiene 281 distritos censales para ocho condados centrales del estado de Nueva York complementado con límites de tramo. El área tiene una extensión de unos 160 km de norte a sur y de 120 km de este a oeste.

```{r librerías}
library(rgdal)
library(sf)
library(spdep)
```

````{r}
NY8 <- readOGR("Base de datos", "NY8_utm18")
TCE <- readOGR("Base de datos", "TCE")
cities <- readOGR("Base de datos", "NY8cities")
```

```{r}
par(mfrow=c(1,2))
plot(NY8, border="grey60", axes=TRUE)
text(coordinates(cities), labels=as.character(cities$names), font=2, cex=0.9)
text(bbox(NY8)[1,1], bbox(NY8)[2,2], labels="a)", cex=0.8)
plot(NY8, border="grey60", axes=TRUE)
points(TCE, pch=1, cex=0.7)
points(TCE, pch=3, cex=0.7)
text(coordinates(TCE), labels=as.character(TCE$name), cex=0.7,
 font=1, pos=c(4,1,4,1,4,4,4,2,3,4,2), offset=0.3)
text(bbox(NY8)[1,1], bbox(NY8)[2,2], labels="b)", cex=0.8)
```

La figura $a)$ muestra las principales ciudades en el área de estudio y $b)$ la ubicación de 11 sitios de desechos peligrosos.

```{r}
spplot(NY8, c("PCTAGE65P"))
spplot(NY8, c("PCTAGE65P"), col="transparent")
```
```{r}
library("RColorBrewer")
#color palette creator function
rds <- colorRampPalette(brewer.pal(8, "RdBu"))
#get a range for the values
tr_at <- seq(min(NY8$PCTAGE65P), max(NY8$PCTAGE65P), length.out=20)
#create a color interpolating function taking the required
#number of shades as argument
tr_rds <- rds(20)
#parameters
# at - at which values colors change
# col.regions - specify fill colors 
tr_pl <- spplot(NY8, c("PCTAGE65P"), at=tr_at, col="transparent",
                col.regions=tr_rds, main=list(label="Age>65", cex=0.8))
plot(tr_pl)

```

# Vecinos espaciales y peso espacial

La creación de ponderaciones espaciales es un paso necesario en el uso de datos de área, quizás solo para verificar que no haya patrones espaciales restantes en los residuos. El primer paso es definir a qué relaciones entre observaciones se les dará un peso distinto de cero, es decir, elegir el criterio de vecino que se usará; el segundo es asignar pesos a los enlaces vecinos identificados.

Tratar de detectar patrones en mapas de residuos visualmente no es una opción aceptable, por lo que se incluyen un montón de funciones en el paquete **spdep** para ayudar.

Las viñetas **"nb","CO69" ** y **"sids"** en **spdep** incluyen discusiones sobre la creación y el uso de ponderaciones espaciales, y se pueden acceder a ellas de la siguiente manera:

```{r}
vignette("nb",package = "spdep")
```

## Objetos vecinos

En el paquete spdep, las relaciones vecinas entre **n** observaciones están representadas por un objeto de clase **nb**. Es una lista de longitud n con los números de índice de vecinos de cada componente registrados como un vector entero. Si alguna observación no tiene vecinos, el componente contiene un número entero cero. También contiene atributos, típicamente un vector de identificadores de región de caracteres y un valor lógico que indica si las relaciones son simétricas. Los identificadores de región pueden usarse para verificar la integridad entre los datos mismos y el objeto vecino.

La función auxiliar **card** devuelve la cardinalidad del conjunto de vecinos para cada objeto, es decir, el número de vecinos.

```{r}
# reads a GAL lattice file into a neighbors list
NY_nb <- read.gal("Base de datos/NY_nb.gal", region.id = row.names(NY8))
summary(NY_nb)
```

```{r}
par(mfrow=c(1,1))
plot(NY8, border="grey60", axes=TRUE)
plot(NY_nb, coordinates(NY8), pch=19, cex=0.6, add=TRUE)
```

La figura muestra el gráfico vecino completo para el área de estudio de ocho condados.

Como ahora se tiene un objeto nb para examinar, se pueden presentar los métodos estándar para estos objetos. Hay métodos  de impresión, resumen, diagrama y otros; el método de resumen presenta una tabla de la distribución del número de enlace, y tanto el método de impresión como el de resumen informan de la asimetría y la presencia de observaciones sin vecinos; la asimetría está presente cuando $i$ es un vecino de $j$ pero $j$ no es un vecino de $i$.

Con motivos de simplicidad al mostrar como crear objetos vecinos, se trabaja con un subconjunto del mapa que consta de los censos dentro de Syracuse, aunque los mismos principios se aplican al conjunto de datos completo. 

```{r}
Syracuse <- NY8[NY8$AREANAME == "Syracuse city",]
Sy0_nb <- subset(NY_nb, NY8$AREANAME == "Syracuse city")
summary(Sy0_nb)
```

```{r}
coords <- coordinates(Syracuse)
IDs <- row.names(Syracuse)
Sy8_nb <- knn2nb(knearneigh(coords, k = 1), row.names = IDs)
Sy9_nb <- knn2nb(knearneigh(coords, k = 2), row.names = IDs)
Sy10_nb <- knn2nb(knearneigh(coords, k = 4), row.names = IDs)
dsts <- unlist(nbdists(Sy8_nb, coords))
Sy11_nb <- dnearneigh(coords, d1 = 0, d2 = 0.75 * max(dsts), 
                      row.names = IDs)
```


## Objetos de ponderaciones espaciales

La ponderación espacial se puede ver como una lista de ponderaciones espaciales indexadas por una lista de vecinos entre \textit{i}  y  \textit{j}  esel \textit{k-ésimo} elemento del \textit{i-ésimo} componente de la lista de ponderaciones, y \textit{k} nos dice cual de los \textit{i-ésimos} valores del componente de la lista de vecinos es igual a \textit{j}. Si \textit{j} no está presente en el \textit{i-ésimo} componente de la lista de vecinos, \textit{j} no es un vecino de \textit{i}. Por ello algunas de las ponderaciones \textit{$w_{ij}$} de la matriz de ponderaciones serán cero.

Una vez se establece la lista de los conjuntos de los vecinos en nuestra área de estudio, se procese a asignar los pesos espaciales, también es de tener en cuenta que se utiliza una notación bionaria cuando se sabe poco del proceso especial, dónde no hay una relación de vecino se pone 0 (cero) en caso contrario será la unidad.

La función `nb2listw` toma una lista de vecinos y lo convierte en un objeto de pesos. La conversión de los pesos se hace con un estilo $W$ que se hace bajo una estandarización por fila para sumar la unidad. El método de impresión \textit{(print)} para los objetos \text{listw} muestran las características de los vecinos subyacentes, el estilo de las ponderaciones espaciales y las constantes de las ponderaciones espaciales utilizadas en el cálculo de las pruebas de auto-correlación espacial. El componente de vecinos del objeto es el objeto nb subyacente, que proporciona la indexación del componente de ponderaciones.

```{r}
Sy0_lw_W <- nb2listw(Sy0_nb); Sy0_lw_W

names(Sy0_lw_W)

names(attributes(Sy0_lw_W))
```

Para el `style = "W"`,  los pesos varían entre la unidad divida por el mayor y el menor número de vecinos, y las sumas de los pesos para cada entidad de área son la unidad. Este estilo se puede interpretar como el \textbf{valor medio entre vecinos}. Los pesos de los enlaces que se originan en áreas con pocos vecinos son mayores que los que se originan en áreas con muchos vecinos, quizá aumentando las entidades de área en el borde del área de estudio sin querer. Esta representación ya no es simétrica, pero es similar tiende a ser simétrica.

```{r}
1/rev(range(card(Sy0_lw_W$neighbours)))

summary(unlist(Sy0_lw_W$weights))

summary(sapply(Sy0_lw_W$weights, sum))
```

\textbf{Las funciones:}

- `card` cuenta el número de vecinos en cada región en la lista de vecinos.

- `range` toma el valor mínimo y el máximo.

- `rev` revierte el vector 

- `unlist` saca la información o datos atómicos de una lista

- `sapply` aplica la función suma a cada uno de los vectores asociado a las áreas.

La configuración de `style = "B"` - \textit{Binario} retiene un peso de unidad para cada relación de vecino, pero en este caso, las sumas de pesos de las áreas difieren según el número de áreas vecinas que tienen.

```{r}
Sy0_lw_B <- nb2listw(Sy0_nb, style = "B")
summary(unlist(Sy0_lw_B$weights))
summary(sapply(Sy0_lw_B$weights, sum))
```

El argumento `glist` se puede utilizar para pasar una lista de vectores de pesos generales correspondientes a las relaciones vecinas a `nb2list`. En este ejecicio se cree que la fuerza de las relaciones con los vecinos se atenúa con la distancia, por ello se estable en los pesos para que sean proporcionales ala distancia inversa entre los puntos que representan las áreas, usando `nbdists`para calcular las distancias para el objeto `nb` dado. Luego se usa `lapply` para invertir las distancias, obteniendo una estructura de pesos espaciales diferente a los anteriores. Si no se tiene ninguna razón para asumir más conocimiento sobre las relaciones con los vecinos que su existencia o ausencia, este paso es potencialmente engañoso. Si se sabe que el flujo de desplazamiento describen la estructura de las ponderaciones mejor que la alternativa binaria, puede valer la pena utilizarlas como ponderaciones generales; Sin embargo, puede haber problemas de simetría, porque tales flujos a diferencia de las distancias inversas, rara vez son simétricas.

```{r}
dsts <- nbdists(Sy0_nb, coordinates(Syracuse))
idw <- lapply(dsts, function(x) 1/(x/1000))
Sy0_lw_idwB <- nb2listw(Sy0_nb, glist = idw, style = "B")
summary(unlist(Sy0_lw_idwB$weights))
summary(sapply(Sy0_lw_idwB$weights, sum))
```

\textbf{La función:}

- `nbdists` devuelve las distancias euclidianas dadas por un vector de enlaces de vecinos (un objeto nb). 

- `nb2listw` toma una lista de vecinos y lo convierte en un objeto de pesos.

- `lapply` aplica a cada distancia euclidiana el inverso.

La siguiente figura muestra tres representaciones de ponderaciones espaciales para Syracuse mostradas como matrices. La imagen `style = "W"` de la izquierda es asimétrica, con colores más oscuros ue muestran pesos más gandes para áreas con pocos vecinos. Los otros dos paneles son simétricos, pero expresan diferentes suposiciones sobre las fortalezas de las relaciones con los vecinos. 

![Tres representaciones de ponderaciones espaciales para Syracuse](matrices-ponderaciones.png)

La función `nb2listw` permite manejar listas de vecinos con áreas sin vecinos. Esto es debido porque la representación del conjunto vacío sea cero y debería ser representado como `NA` pero esto generaría problemas más adelante.

Es por esta razón que el argumento predeterminado es `cero.policy=FALSE`, lo que genera un error cuando se proporciona un argumento `nb` con áreas sin vecinos. Con el argumento `TRUE`permite la creación del objeto de ponderaciones espaciales, con ponderaciones cero. 

```{r, error=TRUE}
Sy0_lw_D1 <- nb2listw(Sy11_nb, style = "B")
Sy0_lw_D1 <- nb2listw(Sy11_nb, style = "B", zero.policy = TRUE)
print(Sy0_lw_D1, zero.policy = TRUE)
```

Un problema paralelo de los conjuntos de datos con valores perdidos en las variables pero con ponderaciones espaciales especificadas se aborda mediante el método `subset.listw`, que vuelve a generar las ponderaciones para el subconjunto de áreas dado, por ejemplo, dado por `complete.cases`. Sabiendo qué observaciones están incompletas, los vecinos subyacentes y las ponderaciones se pueden subdividir en algunos casos, con el objetivo de evitar la propagación de los valores `NA` al calcular los valores con retraso espacial. Muchas pruebas y funciones de ajuste de modelos pueden llevar a cabo esto internamente si se establece el indicador de argumento apropiado, aunque el analista cuidadoso preferirá subconjuntos de los datos de entrada y los pesos antes de probar o modelar.

## Manejo de objetos de ponderaciones espaciales

Hay varios paquetes contribuidos que brindan soporte para matrices dispersas, entre las cuales `Matrix` es un paquete recomendado. La envoltura `as_dgRMatrix_listw` convierte un objeto `listw` en  la  matriz  dispersa  de  formato  orientado  a  filas  comprimidas  ordenadas  por  `Matrix`,  como un objeto `dgRMatrix`, una subclase de la clase virtual `RsparseMatrix`. Es más fácil hacer una matriz dispersa orientada a filas a partir de un objeto de ponderaciones espaciales, ya que las ponderaciones están orientadas a filas. Una función que se usa mucho dentro de las funciones de prueba y ajuste de modelos es `listw2U`, que devuelve un objeto `listw` simétrico que representa la matriz de ponderaciones espaciales $\frac{1}{2}(W+W^T)$

Los objetos vecinos y de pesos pueden ser producidos en otros software e importarse a R y además se pueden exportar sin dificultad. Como ejemplo se han generado algunos archivos de [GeoDa](https://sgsup.asu.edu/geodacenter-redirect) a partir de distritos censales de Syracuse escritos como un shapefile, con el centroide utilizando aquí almacenado en el marco de datos. Los dos primeros son para vecinos de contigüidad. Estos archivos denomidos en formato GAL contienen solo información de vecinos y se describen en detalle en el archivo de ayuda que acompaña a la función `read.gal` 

```{r}
Sy14_nb <- read.gal("Base de datos/Sy_GeoDa1.GAL")
isTRUE(all.equal(Sy0_nb, Sy14_nb, check.attributes = FALSE))
```

La función `write.nb.ga` se utiliza para escribir archivos en formato `GAL` a partir de `nb` objetos.

```{r}
Sy16_nb <- read.gwt2nb("Base de datos/Sy_GeoDa4.GWT")
isTRUE(all.equal(Sy10_nb, Sy16_nb, check.attributes = FALSE))
```


## Uso de pesos para simular la autocorrelación espacial

# Prueba de autocorrelación espacial

## Pruebas globales

## Pruebas locales

# Ajuste de modelos de datos de área

## Enfoques de estadística espacial

### Modelos autorregresivos simultáneos

### Modelos autorregresivos condicionales

### Ajuste de modelos de regresión espacial


